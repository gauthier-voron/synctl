#!/bin/bash
#
#

set -e

INODE_PROPERTIES=()

set_inode_properties() {
    local devino="$1" ; shift
    local perm="$1" ; shift
    local atime="$1" ; shift
    local mtime="$1" ; shift

    INODE_PROPERTIES+=("$devino:$perm:$atime:$mtime")
}

get_inode_properties() {
    local devino="$1" ; shift
    local pair key value

    for pair in "${INODE_PROPERTIES[@]}" ; do
	key="${pair%%:*}"
	if [ "x$key" != "x$devino" ] ; then
	    continue
	fi

	value="${pair#*:}"
	printf "%s" "${value%%:*}"

	value="${value#*:}"
	printf " %s %s\n" "${value%:*}" "${value#*:}"
    done
}

get_type() {
    local mode="$1" ; shift
    local ftype ntype

    ftype=${mode:0:-4}

    ntype=${ftype##0}
    while [ "x$ntype" != "x$ftype" ] ; do
	ftype=$ntype
	ntype=${ftype##0}
    done

    echo $ftype
}

get_perm() {
    local mode="$1" ; shift
    local perm="${mode: -4}"

    echo "$perm"
}

vtest() {
    local path="$1" ; shift
    local desc="$1" ; shift

    if ! test "$@" 2> /dev/null ; then
	printf "check failed for '%s' : %s\n" "$path" "$desc"
	echo " " "$@"
	false
    fi
}

get_suffix() {
    local rem="$1" ; shift

    while [ "x$rem" != 'x' ] ; do
	read -r opt rem <<< "$rem"
	if [ "x$opt" = 'x=' -o "x$opt" = 'x<' ] ; then
	    echo "$opt" "$rem"
	    return
	fi
    done
}

check_xattr() {
    local path="$1" ; shift
    local opt="$1" ; shift
    local name="${opt%%=*}"
    local value="${opt#*=}"

    test "x$name" != 'x'
    vtest "$path" "x:$opt" "x$(getfattr -h --only-values -n "$name" "$path")" = "x$value"
}

check_owner() {
    local path="$1" ; shift
    local owner="$1" ; shift

    test "x$path" != 'x'

    if echo "$owner" | grep -Pq '^\d+$' ; then
	vtest "$path" "o:$owner" "x$(stat -c '%u' "$path")" = "x$owner"
    else
	vtest "$path" "o:$owner" "x$(stat -c '%U' "$path")" = "x$owner"
    fi
}

check_group() {
    local path="$1" ; shift
    local group="$1" ; shift

    test "x$path" != 'x'

    if echo "$group" | grep -Pq '^\d+$' ; then
	vtest "$path" "g:$group" "x$(stat -c '%g' "$path")" = "x$group"
    else
	vtest "$path" "g:$group" "x$(stat -c '%G' "$path")" = "x$group"
    fi
}

check_hardlink() {
    local path0="$1" ; shift
    local path1="$1" ; shift
    local devino0=$(stat -c '%D.%i' "$path0")
    local devino1=$(stat -c '%D.%i' "$path1")

    vtest "$path0" "hard link of '$path1'" "$devino0" = "$devino1"
}

check_options() {
    local path="$1" ; shift
    local rem="$1" ; shift

    while [ "x$rem" != 'x' ] ; do
	read -r opt rem <<< "$rem"
	if [ "x$opt" = 'x=' -o "x$opt" = 'x<' ] ; then
	    return
	fi

	if [ "x${opt:0:2}" = 'xx:' ] ; then
	    check_xattr "$path" "${opt:2}"
	elif [ "x${opt:0:2}" = 'xo:' ] ; then
	    check_owner "$path" "${opt:2}"
	elif [ "x${opt:0:2}" = 'xg:' ] ; then
	    check_group "$path" "${opt:2}"
	else
	    false
	fi
    done
}

check_dir() {
    local path="$1" ; shift
    local rem="$1" ; shift

    test "x$(get_suffix "$rem")" = 'x'

    vtest "$path" 'type' ! -L "$path"
    vtest "$path" 'type' -d "$path"

    check_options "$path" "$rem"
}

check_regular() {
    local path="$1" ; shift
    local rem="$1" ; shift
    local symbol content target

    vtest "$path" 'type' ! -L "$path"
    vtest "$path" 'type' -f "$path"

    read -r symbol content <<< "$(get_suffix "$rem")"

    case $symbol in
	'<')
	    temp=$(mktemp -t --suffix='.txt' 'chktree.XXXXXXXXX')
	    printf "$content" > "$temp"
	    if ! diff -Naur "$temp" "$path" ; then
		rm "$temp"
		false
	    else
		rm "$temp"
	    fi
	    ;;
	'=')
	    target="${prefix}${content}"
	    check_hardlink "$target" "$path"
	    ;;
	'')  vtest "$path" 'empty' $(stat -c '%s' "$path") = 0 ;;
	*)   false ;;
    esac

    check_options "$path" "$rem"
}

check_symlink() {
    local path="$1" ; shift
    local rem="$1" ; shift
    local symbol target

    vtest "$path" 'type' -L "$path"

    read -r symbol target <<< "$(get_suffix "$rem")"

    case $symbol in
	'=') vtest "$path" 'target' "x$(readlink "$path")" = "x$target" ;;
	*)   false ;;
    esac

    check_options "$path" "$rem"
}


prefix=
roots=()
entries=()

while [ $# -gt 0 ] ; do
    case "$1" in
	'-p') shift; prefix="$1" ;;
	'--') shift; break ;;
    esac
    shift
done

if [ "x$prefix" != 'x' ] ; then
    if [ "${prefix: -1}" != '/' ] ; then
	prefix="$prefix/"
    fi
fi

while read -r path mode atime mtime rem ; do
    path="${prefix}${path}"
    ftype=$(get_type $mode)
    perm="$(get_perm $mode)"

    gatime=$(stat -c '%x' "$path" | cut -d' ' -f1 | tr -d '-')
    gmtime=$(stat -c '%y' "$path" | cut -d' ' -f1 | tr -d '-')
    gperm=$(stat -c '%a' "$path")
    gdevino=$(stat -c '%D.%i' "$path")
    gstored=$(get_inode_properties "$gdevino")

    if [ "x$gstored" != 'x' ] ; then
	read gperm gatime gmtime <<< "$gstored"
    else
	set_inode_properties "$gdevino" "$gperm" "$gatime" "$gmtime"
    fi

    if [ "$atime" != '*' ] ; then
	vtest "$path" 'access time' $gatime = $atime
    fi

    if [ "$mtime" != '*' ] ; then
	vtest "$path" 'modification time' $gmtime = $mtime
    fi

    if [ "$perm" != '****' ] ; then
	vtest "$path" 'permissions' $gperm -eq $perm
    fi

    if [ $ftype -ne 12 ] ; then
	chmod 777 "$path"
    fi

    case $ftype in
	4)  check_dir     "$path" "$rem" ;;
	10) check_regular "$path" "$rem" ;;
	12) check_symlink "$path" "$rem" ;;
	*)  false ;;
    esac

    entries+=("$path")

    if [ $ftype -eq 4 ] ; then
	isroot=1
	for root in "${roots[@]}" ; do
	    if [ "x${path#$root}" != "x$path" ] ; then
		isroot=0
		break
	    fi
	done

	if [ $isroot -eq 1 ] ; then
	    roots+=("$path")
	fi
    fi
done

for root in "${roots[@]}" ; do
    find "$root" | while read child ; do
	valid=0
	for entry in "${entries[@]}" ; do
	    if [ "x$entry" = "x$child" ] ; then
		valid=1
		break
	    fi
	done

	vtest "$child" 'unexpected entry' \
	      $valid -eq 1
    done
done
